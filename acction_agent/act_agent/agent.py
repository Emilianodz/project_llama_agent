import os
import dotenv
import json
from llama_index.core.agent import FunctionCallingAgentWorker
from llama_index.core.tools import FunctionTool
from llama_index.llms.openai import OpenAI
from .utils import get_info_by_iccid, plan_service_info, increment_data_plan, get_id_by_email
from typing import Dict, Any

# Cargar las variables de entorno desde .env
dotenv.load_dotenv()
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")

# Clase LLMAgent que encapsula la lógica del agente
class LLMAgent:
    def __init__(self):
        # Diccionario para almacenar información del usuario y su plan
        self.autogenerated_model_info = {
            "companyClientId": None,
            "iccid": None,
            "simId": None,
            "annexId": None,
            "planId": None,
            "planName": None,
            "supplierId": None,
            "idSupplierPlan": None,
            "mb": None,
            "sku": None,
            "serviceTime": None,
            "userId": None
        }
        
        # Crear la herramienta basada en la función anterior
        tool = FunctionTool.from_defaults(fn=self.increase_data_plan)
        
        # Crear un agente usando FunctionCallingAgentWorker y la herramienta
        self.worker = FunctionCallingAgentWorker.from_tools(
            [tool], 
            llm=OpenAI(api_key=OPENAI_API_KEY, model="gpt-3.5-turbo")
        )
        self.agent = self.worker.as_agent()
        
    # Definir la función/herramienta que el agente invocará
    def increase_data_plan(self, email: str, iccid: str) -> str:
        print(f"llamando a la funcion increase_data_plan")
        """
        Procesa el aumento del plan de datos utilizando el email del usuario y el ICCID de la SIM.
        """
        try:
            # if user_id:
            #     self.autogenerated_model_info['companyClientId'] = user_id
            # Mensaje de error estándar
            error_message = "Error temporal en el servidor. Intente nuevamente más tarde."

            # Obtener el ID del usuario a partir de su email
            if not self.autogenerated_model_info['companyClientId']:
                print("obteniendo ID del usuario...")
                print(f"Email: {email}")
                user_info = get_id_by_email(email)
                if user_info.get('statusCode') == 500:
                    print(f"Error al obtener ID del usuario: {user_info.get('message')}")
                    return error_message
                print(user_info)
                self.autogenerated_model_info['companyClientId'] = user_info['companyClientId']
                print(self.autogenerated_model_info['companyClientId'])
                self.autogenerated_model_info['userId'] = user_info['id']
                print(self.autogenerated_model_info['userId'])
                print(f"User info obtained: {user_info}")
                
            # Obtener información de la SIM usando el ICCID
            if not self.autogenerated_model_info['simId']:
                print("Obteniendo SIM...")
                sim_info = get_info_by_iccid(iccid, self.autogenerated_model_info['companyClientId'])
                if sim_info.get('statusCode') == 500:
                    print(f"Error al obtener información de la SIM: {sim_info.get('message')}")
                    return error_message
                self.autogenerated_model_info['simId'] = sim_info['id']
                print(f"SIM ID obtenido: {self.autogenerated_model_info['simId']}")
                
            # Obtener información del plan de datos
            if not self.autogenerated_model_info['planId']:
                print("Obteniendo plan de datos...")
                plan_info_response = plan_service_info(self.autogenerated_model_info['simId'])
                
                if plan_info_response.get('statusCode') == 500:
                    print(f"Error al obtener información del plan de datos: {plan_info_response.get('message')}")
                    return error_message
                
                plan_info = plan_info_response.get('data', {})
                
                if not plan_info:
                    error_message = "Error temporal en el servidor. Intente nuevamente más tarde."
                    print("No se pudo obtener la información del plan de datos. La respuesta está vacía.")
                    print(error_message)
                    return error_message
                
                self.autogenerated_model_info.update({
                    'annexId': plan_info.get('annexId'),
                    'planId': plan_info.get('planId'),
                    'planName': plan_info.get('planName'),
                    'supplierId': plan_info.get('supplierId'),
                    'idSupplierPlan': plan_info.get('idSupplierPlan'),
                    'sku': plan_info.get('sku'),
                    'serviceTime': plan_info.get('serviceTime'),
                    'mb': plan_info.get('mb')
                })
                print("Datos del plan obtenidos:", self.autogenerated_model_info)
                
            # Aumentar el plan de datos
            if all(self.autogenerated_model_info[key] is not None for key in [
                'simId', 'annexId', 'planId', 'planName', 'supplierId', 'idSupplierPlan',
                'mb', 'sku', 'serviceTime', 'userId'
            ]):
                print("Incrementando plan de datos...")
                resultado = increment_data_plan(
                    int(self.autogenerated_model_info['simId']),
                    int(self.autogenerated_model_info['annexId']),
                    int(self.autogenerated_model_info['planId']),
                    str(self.autogenerated_model_info['planName']),
                    int(self.autogenerated_model_info['supplierId']),
                    int(self.autogenerated_model_info['idSupplierPlan']),
                    int(self.autogenerated_model_info['mb']),
                    str(self.autogenerated_model_info['sku']),
                    int(self.autogenerated_model_info['serviceTime']),
                    int(self.autogenerated_model_info['userId'])
                )
                if resultado.get('statusCode') == 500:
                    print(f"Error al incrementar el plan de datos: {resultado.get('message')}")
                    return error_message
                print(f"Resultado del aumento del plan: {resultado}")
                return resultado
            else:
                return "No se pudo incrementar el plan de datos. Faltan datos necesarios."
            
        except Exception as e:
            print(f"Error al intentar aumentar el plan de datos: {e}")
            return error_message

    def process_query(self, query: str) -> str:
        """Método que recibe una consulta y devuelve la respuesta del agente"""
        response = self.agent.chat(query)
        return str(response)



"""
class LLMAgent:
    def __init__(self):
        # Definir la función/herramienta que el agente invocará
        def get_the_secret_fact() -> str:
            Devuelve un hecho secreto.
            return "The secret fact is: A baby llama is called a 'Cria'."

        # Crear la herramienta basada en la función anterior
        tool = FunctionTool.from_defaults(fn=get_the_secret_fact)

        # Crear un agente usando FunctionCallingAgentWorker y la herramienta
        self.worker = FunctionCallingAgentWorker.from_tools(
            [tool], 
            llm=OpenAI(api_key=OPENAI_API_KEY, model="gpt-3.5-turbo")
        )
        self.agent = self.worker.as_agent()

    def process_query(self, query: str) -> str:
        Método que recibe una consulta y devuelve la respuesta del agente
        response = self.agent.chat(query)
        return str(response)
"""